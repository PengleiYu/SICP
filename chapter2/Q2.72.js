import {display_list, error, head, is_number, is_pair, is_string, list, tail, equal, is_null, pair, length} from "sicp";

// 考虑huffman编码的时间复杂度
(function () {
    // 练习2.72 考虑你在练习2.68中设计的编码函数。编码一个符号，计算步数的增长速度如何？这里必须计入遇到每个结点时检查符号表所需的步数。
    // 一般性地回答这个问题非常困难。考虑一类特殊情况，其中n个符号的相对频度如练习2.71所述。请给出编码最频繁符号所需的步数和编码最不频繁符号所需的步数的增长速度（作为n的函数）。


    // 按2.71所给的频度表
    // 树的形式应该是一条斜线，树高为n
    // 编码时需要考虑查询符号表的步数，每个树节点都有个符号表，符号表按频次从小到大排列
    // 出现最频繁的符号是第2层右叶子，只遍历了一层，由于频次最大，查询n次才会命中，所以总步数为n
    // 最不频繁的符号是第n层左叶子，需要遍历n-1层，由于频次最小，每层查询一次就命中，所以总步数为n-1
    // 对于普通的符号，忽略频次最高的符号，假设在字母表中顺序为i，从0开始，则频度为2^(i-1)，所在树层级为n-i,需要遍历的层数为n-i-1，
    // 遍历符号表时查询次数为i+1，所以总步数为(n-i-1)*(i+1)
})();
